import{eo as w,gc as q,gd as B,ge as D,gf as I,gg as P,e$ as d,P as s,Q as e,Y as X,aX as Y,gh as k,aY as z,ej as l,gi as C,eD as F,gj as G,X as H}from"./index-i1xHX9d5.js";import{e as x}from"./mat4f64-CSKppSlJ.js";import{v as M,b as p,x as Q}from"./quat-CVl3iR4g.js";import{e as f}from"./quatf64-aQ5IuZRd.js";function a(t=v){return[t[0],t[1],t[2],t[3]]}function c(t,o,n=a()){return w(n,t),n[3]=o,n}function L(t,o=a()){const n=P(i,t);return j(o,d(M(o,n))),o}function y(t,o,n=a()){return p(i,t,h(t)),p(A,o,h(o)),Q(i,A,i),j(n,d(M(n,i)))}function O(t,o,n,m=a()){return c(q,t,u),c(B,o,$),c(D,n,N),y(u,$,u),y(u,N,m),m}function R(t){return t}function T(t){return t[3]}function h(t){return I(t[3])}function j(t,o){return t[3]=o,t}const v=[0,0,1,0],i=f(),A=f();a();const u=a(),$=a(),N=a();var g;let r=g=class extends X{constructor(t){super(t),this.translation=Y(),this.rotationAxis=k(v),this.rotationAngle=0,this.scale=z(1,1,1)}get rotation(){return c(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=l(t),this.rotationAngle=T(t)}get localMatrix(){const t=x();return p(b,this.rotation,h(this.rotation)),C(t,b,this.translation,this.scale),t}get localMatrixInverse(){return F(x(),this.localMatrix)}equals(t){return this===t||t!=null&&G(this.localMatrix,t.localMatrix)}clone(){const t={translation:l(this.translation),rotationAxis:l(this.rotationAxis),rotationAngle:this.rotationAngle,scale:l(this.scale)};return new g(t)}};s([e({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"translation",void 0),s([e({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAxis",void 0),s([e({type:Number,nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAngle",void 0),s([e({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"scale",void 0),s([e()],r.prototype,"rotation",null),s([e()],r.prototype,"localMatrix",null),s([e()],r.prototype,"localMatrixInverse",null),r=g=s([H("esri.geometry.support.MeshTransform")],r);const b=f(),S=r;export{S as N,O as d,a as j,L as k,R as w,h as z};
