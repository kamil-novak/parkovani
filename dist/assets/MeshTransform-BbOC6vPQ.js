import{en as w,gx as B,gy as D,gz as q,gA as z,gB as C,f8 as M,a7 as a,a8 as i,ac as I,aV as k,gC as E,aW as F,ei as l,gD as G,eD as H,gE as P,ab as T}from"./index-DcJadwK6.js";import{e as m}from"./mat4f64-CSKppSlJ.js";import{v as d,b as p,x as U}from"./quat-Bsq-xRzg.js";import{e as x}from"./quatf64-aQ5IuZRd.js";function s(t=j){return[t[0],t[1],t[2],t[3]]}function c(t,o,n=s()){return w(n,t),n[3]=o,n}function O(t,o=s()){const n=C(e,t);return v(o,M(d(o,n))),o}function y(t,o,n=s()){return p(e,t,h(t)),p(A,o,h(o)),U(e,A,e),v(n,M(d(n,e)))}function Q(t,o,n,f=s()){return c(B,t,u),c(D,o,$),c(q,n,b),y(u,$,u),y(u,b,f),f}function R(t){return t}function V(t){return t[3]}function h(t){return z(t[3])}function v(t,o){return t[3]=o,t}const j=[0,0,1,0],e=x(),A=x();s();const u=s(),$=s(),b=s();var g;let r=g=class extends I{constructor(t){super(t),this.translation=k(),this.rotationAxis=E(j),this.rotationAngle=0,this.scale=F(1,1,1)}get rotation(){return c(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=l(t),this.rotationAngle=V(t)}get localMatrix(){const t=m();return p(N,this.rotation,h(this.rotation)),G(t,N,this.translation,this.scale),t}get localMatrixInverse(){return H(m(),this.localMatrix)}equals(t){return this===t||t!=null&&P(this.localMatrix,t.localMatrix)}clone(){const t={translation:l(this.translation),rotationAxis:l(this.rotationAxis),rotationAngle:this.rotationAngle,scale:l(this.scale)};return new g(t)}};a([i({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"translation",void 0),a([i({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAxis",void 0),a([i({type:Number,nonNullable:!0,json:{write:!0}})],r.prototype,"rotationAngle",void 0),a([i({type:[Number],nonNullable:!0,json:{write:!0}})],r.prototype,"scale",void 0),a([i()],r.prototype,"rotation",null),a([i()],r.prototype,"localMatrix",null),a([i()],r.prototype,"localMatrixInverse",null),r=g=a([T("esri.geometry.support.MeshTransform")],r);const N=x(),S=r;export{S as N,Q as d,s as j,O as k,R as w,h as z};
